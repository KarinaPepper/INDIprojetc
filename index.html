<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Алгоритмы </title>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" href="/Users/ilia_dumov/Desktop/ballsbird/bird3.jpeg" type="image/x-icon" sizes="any" class="roundgg">

    
    
</head>
<body>
    <header>
    <a href ="#" class="Dropown"> Алгоримы и Блок-Схемы </a>

    
    <nav>
            <ul>

                <li id="sostep1"><a href = "#">Поиск  &blacktriangledown;</a>
                    <ul>
                        <li><a href="#steps4">линейный</a></li>
                        <li><a href="#steps5">банарный</a></li>
                        <li><a href="#steps6">прыжковый</a></li>
                    </ul>
                </li>
                <li id="sostep2"><a href = "#">Сортировка &blacktriangledown;</a>
                    <ul>
                        <li><a href="#steps">пузырьком</a></li>
                        <li><a href="#steps2">выбором</a></li>
                        <li><a href="#steps3">вставками</a></li>
                    </ul>
                </li>


            </ul>
  
    </nav>
    </header>
    <main>
        <section>
            <h2>Описание</h2>
            <p>Линейный поиск — простой алгоритм поиска, который перебирает каждый элемент массива по очереди. Он подходит для небольших массивов или ситуаций, когда данные не отсортированы</p>

        </section>
        <section>
            <h2>Принцип работы</h2>
            <ol id="steps4">
                <li>Перебор элементов: Каждый элемент массива перебирается по очереди.</li>
                <li>Сравнение: Каждый элемент сравнивается с искомым значением.</li>
                <li>Возвращение индекса: Если элемент найден, возвращается его индекс. Если не найден, возвращается специальное значение (например, -1).</li>
            </ol>


        </head>
        <body>
            <button class = "btn" data-name = "load-image-btn4" data-div = "image-container4" data-text="step-algo">показать блок-схему</button>
            <div id="image-container4"></div>
            <div id="step-algo"></div>


            
            
            <div id="codeDisplay3" style="margin-top: 20px;"></div>
        </section>
        <section>
            <h2>Пример кода на Python</h2>
            <pre><code>
    def linear_search(arr, target):
        for i in range(len(arr)):
            if arr[i] == target:
                return i
        return -1
            
    # Пример использования
    arr = [10, 20, 30, 40, 50]
    target = 30
    index = linear_search(arr, target)
    print(f'Элемент найден на индексе: {index}')
                    
            </code></pre>
        
        
        </section>

        <section>
            <h2>Описание</h2>
            <p>Бинарный поиск — эффективный алгоритм поиска, который работает только с отсортированными массивами. Он делит массив пополам на каждом шаге, что делает его очень быстрым для больших данных.</p>

        </section>
        <section>
            <h2>Принцип работы</h2>
            <ol id="steps5">
                <li>Отсортированный массив: Бинарный поиск работает только с отсортированным массивом данных.</li>
                <li>Деление пополам: Массив делится пополам, и определяется средний элемент.</li>
                <li>Сравнение: Средний элемент сравнивается с искомым значением.</li>
                <li>Повторение: Если искомое значение больше среднего, поиск продолжается в правой половине. Если меньше, то в левой. Процесс повторяется до тех пор, пока не будет найден искомый элемент или не останется один элемент.</li>
                
            </ol>


        </head>
        <body>
            <button class = "btn" data-name = "load-image-btn5" data-div = "image-container5">показать блок-схему</button>
            <div id="image-container5"></div>

            
            
            <div id="codeDisplay3" style="margin-top: 20px;"></div>
        </section>
        <section>
            <h2>Пример кода на Python</h2>
            <pre><code>
                
    def binary_search(arr, target):
        left, right = 0, len(arr) - 1
        while left <= right:
            mid = (left + right) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
            
    # Пример использования
    arr = [10, 20, 30, 40, 50]
    target = 40
    index = binary_search(arr, target)
    print(f'Элемент найден на индексе: {index}')
                    
            </code></pre>
        
        
        </section>

        <section>
            <h2>Описание</h2>
            <p>Прыжковый поиск — компромисс между линейным и бинарным поиском. Он работает с отсортированными массивами и использует прыжки для ускорения поиска. Подходит для ситуаций, когда бинарный поиск не подходит.</p>

        </section>
        <section>
            <h2>Принцип работы</h2>
            <ol id="steps6">
                <li>Определение шага прыжка: Шаг прыжка определяется как квадратный корень из длины массива.</li>
                <li>Прыжки: Поиск происходит с помощью прыжков на шаг вперед, пока не будет найден блок, в котором может находиться искомый элемент.</li>
                <li>Линейный поиск в блоке: В найденном блоке выполняется линейный поиск.</li>
            </ol>


        </head>
        <body>
            <button class = "btn" data-name = "load-image-btn6" data-div = "image-container6">показать блок-схему</button>
            <div id="image-container6"></div>

            
            
            <div id="codeDisplay3" style="margin-top: 20px;"></div>
        </section>
        <section>
            <h2>Пример кода на Python</h2>
            <pre><code>
    import math

    def jump_search(arr, target):
        n = len(arr)
        step = int(math.sqrt(n))
                    
        prev = 0
        while arr[min(step, n)-1] < target:
            prev = step
            step += int(math.sqrt(n))
            if prev >= n:
                return -1
                    
        while arr[prev] < target:
            prev += 1
            if prev == min(step, n):
                return -1
                    
        if arr[prev] == target:
            return prev
                    
        return -1
                
    # Пример использования
    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    target = 5
    index = jump_search(arr, target)
    print(f'Элемент найден на индексе: {index}')
            </code></pre>
        
        
        </section>

        <section>
            <h2>Описание</h2>
            <p>Алгоритм последовательно сравнивает соседние элементы списка и меняет их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список не станет отсортированным.</p>
        </section>
        <section>
            <h2>Принцип работы</h2>
            <ol id="steps">
                <li>Сравниваются первые два элемента. Если они в неправильном порядке, меняются местами.</li>
                <li>Процесс продолжается для всех пар соседних элементов до конца списка.</li>
                <li>Самый большой элемент «всплывает» в конец списка.</li>
                <li>Каждый последующий проход сокращает длину неотсортированной части на один элемент (последний элемент уже отсортирован).</li>
                <li>Процесс завершается, когда за проход не произошло ни одной замены.</li>
            </ol>


        </head>
        <body>
            <button class = "btn" data-name = "load-image-btn" data-div = "image-container">показать блок-схему</button>
            <div id="image-container"></div>

            
            
            <div id="codeDisplay" style="margin-top: 20px;"></div>
        </section>
        <section>
            <h2>Пример кода на Python</h2>
            <pre><code>

    def bubble_sort(nums):
        n = len(nums)
        for i in range(n):
            swapped = False
            for j in range(n - i - 1):
                if nums[j] > nums[j + 1]:
                    nums[j], nums[j + 1] = nums[j + 1], nums[j]
                    swapped = True
            if not swapped:
                break
    
    random_list = [12, 8, 3, 20, 11]
    bubble_sort(random_list)
    print(random_list)
                    
            </code></pre>


        <section>
            <h2>Описание</h2>
            <p>Сортировка выбором — это простой алгоритм, который работает путем последовательного выбора наименьшего элемента из неотсортированной части списка и перемещения его в начало отсортированной части.</p>
        </section>
        <section>
            <h2>Принцип работы</h2>
            <ol id="steps2">
                <li>Поиск минимума в неотсортированной части списка (начиная с первого элемента).</li>
                <li>Обмен найденного минимума с первым элементом текущей неотсортированной части.</li>
                <li>Уменьшение неотсортированной части на один элемент.</li>
                <li>Повтор процесса до полной сортировки</li>
            </ol>


        </head>
        <body>
            <button class = "btn" data-name = "load-image-btn2" data-div = "image-container2">показать блок-схему</button>
            <div id="image-container2"></div>

            
            
            <div id="codeDisplay2" style="margin-top: 20px;"></div>
        </section>
        <section>
            <h2>Пример кода на Python</h2>
            <pre><code>

    def selection_sort(nums):
        for i in range(len(nums)):
                         
            lowest_value_index = i
                    
            for j in range(i + 1, len(nums)):
                if nums[j] < nums[lowest_value_index]:
                    lowest_value_index = j
                                       
            nums[i], nums[lowest_value_index] = nums[lowest_value_index], nums[i]
            
    random_list_of_nums = [12, 8, 3, 20, 11]
    selection_sort(random_list_of_nums)
    print(random_list_of_nums)
                    
            </code></pre>
        
        
        </section>


        <section>
            <h2>Описание</h2>
            <p>Сортировка вставками работает путем последовательной вставки каждого элемента в правильное место в отсортированной части списка.</p>

        </section>
        <section>
            <h2>Принцип работы</h2>
            <ol id="steps3">
                <li>Выбор элемента из неотсортированной части (начиная со второго элемента).</li>
                <li>Сдвиг элементов в отсортированной части, пока не найдётся место для вставки выбранного элемента.</li>
                <li>Вставка элемента на правильную позицию.</li>
                <li>Повтор для оставшихся элементов</li>
            </ol>


        </head>
        <body>
            <button class = "btn" data-name = "load-image-btn3" data-div = "image-container3">показать блок-схему</button>
            <div id="image-container3"></div>

            
            
            <div id="codeDisplay3" style="margin-top: 20px;"></div>
        </section>
        <section>
            <h2>Пример кода на Python</h2>
            <pre><code>

    def insertion_sort(arr):
        for i in range(1, len(arr)):
            key = arr[i]
            j = i - 1
            while j >= 0 and key < arr[j]:
                arr[j + 1] = arr[j]
                j -= 1
            arr[j + 1] = key

    # Пример использования
    array = [10, 7, 8, 9, 1, 5]
    insertion_sort(array)
    print("Отсортированный массив:", array)
                    
            </code></pre>
        
        
        </section>



    </main>

    <footer>
        <p>&copy; 2052 Алгоритмы. Все права защищены.</p>
    </footer>


</body>
<script 
        src="script.js">
        
    </script>
</html>
